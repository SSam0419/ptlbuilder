// Code generated by ptlbuilder;
package protocol

import (
	"encoding/binary"
	"fmt"
	"io"
	"net"
	"time"
)

const (
	RegisterClientCommand = "RegisterClient"
	SendMessageCommand    = "SendMessage"
)

type Message struct {
	Command string
	Data    interface{}
}

type RegisterClientMessage struct {
	address string
	content string
}

type SendMessageMessage struct {
	address string
	content string
}

func DecodeMessageFromConn(conn net.Conn) (*Message, error) {
	if err := conn.SetReadDeadline(time.Now().Add(time.Duration(10) * time.Second)); err != nil {
		return nil, fmt.Errorf("setting read deadline: %w", err)
	}

	// read total length of the message first
	totalLenBuf := make([]byte, 2)
	if _, err := io.ReadFull(conn, totalLenBuf); err != nil {
		return nil, fmt.Errorf("reading total length: %w", err)
	}
	totalLen := binary.BigEndian.Uint16(totalLenBuf)

	// make the buffer for storing the whole message
	data := make([]byte, totalLen)
	if _, err := io.ReadFull(conn, data); err != nil {
		return nil, fmt.Errorf("reading message data: %w", err)
	}

	msg := &Message{}
	currentPos := 0

	// Read command
	if len(data) < 2 {
		return nil, fmt.Errorf("message too short for command length")
	}
	cmdLen := binary.BigEndian.Uint16([]byte(data[currentPos:]))
	currentPos += 2

	if len(data) < currentPos+int(cmdLen) {
		return nil, fmt.Errorf("message too short for command")
	}
	msg.Command = string(data[currentPos : currentPos+int(cmdLen)])
	currentPos += int(cmdLen)

	switch msg.Command {

	case RegisterClientCommand:
		data := &RegisterClientMessage{}

		// Read address
		if len(data.address) < currentPos+2 {
			return nil, fmt.Errorf("message too short for address length")
		}
		addressLen := binary.BigEndian.Uint16([]byte(data.address[currentPos:]))
		currentPos += 2

		if len(data.address) < currentPos+int(addressLen) {
			return nil, fmt.Errorf("message too short for address")
		}

		data.address = string(data.address[currentPos : currentPos+int(addressLen)])

		currentPos += int(addressLen)

		// Read content
		if len(data.content) < currentPos+2 {
			return nil, fmt.Errorf("message too short for content length")
		}
		contentLen := binary.BigEndian.Uint16([]byte(data.content[currentPos:]))
		currentPos += 2

		if len(data.content) < currentPos+int(contentLen) {
			return nil, fmt.Errorf("message too short for content")
		}

		data.content = string(data.content[currentPos : currentPos+int(contentLen)])

		currentPos += int(contentLen)

		msg.Data = data

	case SendMessageCommand:
		data := &SendMessageMessage{}

		// Read address
		if len(data.address) < currentPos+2 {
			return nil, fmt.Errorf("message too short for address length")
		}
		addressLen := binary.BigEndian.Uint16([]byte(data.address[currentPos:]))
		currentPos += 2

		if len(data.address) < currentPos+int(addressLen) {
			return nil, fmt.Errorf("message too short for address")
		}

		data.address = string(data.address[currentPos : currentPos+int(addressLen)])

		currentPos += int(addressLen)

		// Read content
		if len(data.content) < currentPos+2 {
			return nil, fmt.Errorf("message too short for content length")
		}
		contentLen := binary.BigEndian.Uint16([]byte(data.content[currentPos:]))
		currentPos += 2

		if len(data.content) < currentPos+int(contentLen) {
			return nil, fmt.Errorf("message too short for content")
		}

		data.content = string(data.content[currentPos : currentPos+int(contentLen)])

		currentPos += int(contentLen)

		msg.Data = data

	default:
		return nil, fmt.Errorf("unknown command: %s", msg.Command)
	}

	return msg, nil
}

func EncodeRegisterClientRequest(address string, content string) ([]byte, error) {
	cmd := RegisterClientCommand
	totalLen := 2 + 2 + len(cmd) + 2 + len(address) + 2 + len(content)

	buf := make([]byte, totalLen)
	currentPos := 0

	// Write total length
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(totalLen-2))
	currentPos += 2

	// Write command
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(len(cmd)))
	currentPos += 2
	copy(buf[currentPos:], cmd)
	currentPos += len(cmd)

	// Write address
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(len(address)))
	currentPos += 2
	copy(buf[currentPos:], address)
	currentPos += len(address)

	// Write content
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(len(content)))
	currentPos += 2
	copy(buf[currentPos:], content)
	currentPos += len(content)

	return buf, nil
}

func EncodeSendMessageRequest(address string, content string) ([]byte, error) {
	cmd := SendMessageCommand
	totalLen := 2 + 2 + len(cmd) + 2 + len(address) + 2 + len(content)

	buf := make([]byte, totalLen)
	currentPos := 0

	// Write total length
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(totalLen-2))
	currentPos += 2

	// Write command
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(len(cmd)))
	currentPos += 2
	copy(buf[currentPos:], cmd)
	currentPos += len(cmd)

	// Write address
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(len(address)))
	currentPos += 2
	copy(buf[currentPos:], address)
	currentPos += len(address)

	// Write content
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(len(content)))
	currentPos += 2
	copy(buf[currentPos:], content)
	currentPos += len(content)

	return buf, nil
}
