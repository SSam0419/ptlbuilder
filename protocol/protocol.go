// Code generated by ptlbuilder;
package protocol

import (
	"encoding/binary"
	"fmt"
	"io"
	"net"
	"time"
)

const (
	RegisterClientCommand = "RegisterClient"
	SendMessageCommand    = "SendMessage"
)

type Message struct {
	Command string
	Data    interface{}
}

type RegisterClientMessage struct {
	Address string
	Content string
}

type SendMessageMessage struct {
	Address string
	Content string
}

func DecodeMessageFromConn(conn net.Conn) (*Message, error) {
	if err := conn.SetReadDeadline(time.Now().Add(time.Duration(10) * time.Second)); err != nil {
		return nil, fmt.Errorf("setting read deadline: %w", err)
	}

	// read total length of the message first
	totalLenBuf := make([]byte, 2)
	if _, err := io.ReadFull(conn, totalLenBuf); err != nil {
		return nil, fmt.Errorf("reading total length: %w", err)
	}
	totalLen := binary.BigEndian.Uint16(totalLenBuf)

	// make the buffer for storing the whole message
	data := make([]byte, totalLen)
	if _, err := io.ReadFull(conn, data); err != nil {
		return nil, fmt.Errorf("reading message data: %w", err)
	}

	msg := &Message{}
	currentPos := 0

	// Read command
	if len(data) < 2 {
		return nil, fmt.Errorf("message too short for command length")
	}
	cmdLen := binary.BigEndian.Uint16([]byte(data[currentPos:]))
	currentPos += 2

	if len(data) < currentPos+int(cmdLen) {
		return nil, fmt.Errorf("message too short for command")
	}
	msg.Command = string(data[currentPos : currentPos+int(cmdLen)])
	currentPos += int(cmdLen)

	switch msg.Command {

	case RegisterClientCommand:
		msgData := &RegisterClientMessage{}

		// Read Address
		if len(data) < currentPos+2 {
			return nil, fmt.Errorf("message too short for Address length")
		}
		AddressLen := binary.BigEndian.Uint16(data[currentPos:])
		currentPos += 2

		if len(data) < currentPos+int(AddressLen) {
			return nil, fmt.Errorf("message too short for Address")
		}

		msgData.Address = string(data[currentPos : currentPos+int(AddressLen)])

		currentPos += int(AddressLen)

		// Read Content
		if len(data) < currentPos+2 {
			return nil, fmt.Errorf("message too short for Content length")
		}
		ContentLen := binary.BigEndian.Uint16(data[currentPos:])
		currentPos += 2

		if len(data) < currentPos+int(ContentLen) {
			return nil, fmt.Errorf("message too short for Content")
		}

		msgData.Content = string(data[currentPos : currentPos+int(ContentLen)])

		currentPos += int(ContentLen)

		msg.Data = msgData

	case SendMessageCommand:
		msgData := &SendMessageMessage{}

		// Read Address
		if len(data) < currentPos+2 {
			return nil, fmt.Errorf("message too short for Address length")
		}
		AddressLen := binary.BigEndian.Uint16(data[currentPos:])
		currentPos += 2

		if len(data) < currentPos+int(AddressLen) {
			return nil, fmt.Errorf("message too short for Address")
		}

		msgData.Address = string(data[currentPos : currentPos+int(AddressLen)])

		currentPos += int(AddressLen)

		// Read Content
		if len(data) < currentPos+2 {
			return nil, fmt.Errorf("message too short for Content length")
		}
		ContentLen := binary.BigEndian.Uint16(data[currentPos:])
		currentPos += 2

		if len(data) < currentPos+int(ContentLen) {
			return nil, fmt.Errorf("message too short for Content")
		}

		msgData.Content = string(data[currentPos : currentPos+int(ContentLen)])

		currentPos += int(ContentLen)

		msg.Data = msgData

	default:
		return nil, fmt.Errorf("unknown command: %s", msg.Command)
	}

	return msg, nil
}

func EncodeRegisterClientRequest(address string, content string) ([]byte, error) {
	cmd := RegisterClientCommand
	totalLen := 2 + 2 + len(cmd) + 2 + len(address) + 2 + len(content)

	buf := make([]byte, totalLen)
	currentPos := 0

	// Write total length
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(totalLen-2))
	currentPos += 2

	// Write command
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(len(cmd)))
	currentPos += 2
	copy(buf[currentPos:], cmd)
	currentPos += len(cmd)

	// Write Address
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(len(address)))
	currentPos += 2
	copy(buf[currentPos:], address)
	currentPos += len(address)

	// Write Content
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(len(content)))
	currentPos += 2
	copy(buf[currentPos:], content)
	currentPos += len(content)

	return buf, nil
}

func EncodeSendMessageRequest(address string, content string) ([]byte, error) {
	cmd := SendMessageCommand
	totalLen := 2 + 2 + len(cmd) + 2 + len(address) + 2 + len(content)

	buf := make([]byte, totalLen)
	currentPos := 0

	// Write total length
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(totalLen-2))
	currentPos += 2

	// Write command
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(len(cmd)))
	currentPos += 2
	copy(buf[currentPos:], cmd)
	currentPos += len(cmd)

	// Write Address
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(len(address)))
	currentPos += 2
	copy(buf[currentPos:], address)
	currentPos += len(address)

	// Write Content
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(len(content)))
	currentPos += 2
	copy(buf[currentPos:], content)
	currentPos += len(content)

	return buf, nil
}

func (m *Message) AsRegisterClient() (*RegisterClientMessage, error) {
	if m.Command != RegisterClientCommand {
		return nil, fmt.Errorf("invalid command type: expected %s, got %s", RegisterClientCommand, m.Command)
	}

	data, ok := m.Data.(*RegisterClientMessage)
	if !ok {
		return nil, fmt.Errorf("invalid data type for RegisterClientMessage")
	}

	return data, nil
}

func (m *Message) AsSendMessage() (*SendMessageMessage, error) {
	if m.Command != SendMessageCommand {
		return nil, fmt.Errorf("invalid command type: expected %s, got %s", SendMessageCommand, m.Command)
	}

	data, ok := m.Data.(*SendMessageMessage)
	if !ok {
		return nil, fmt.Errorf("invalid data type for SendMessageMessage")
	}

	return data, nil
}
