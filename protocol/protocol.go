// Code generated by ptlbuilder;
package protocol

import (
	"encoding/binary"
	"fmt"
	"io"
	"net"
	"time"
)

const (
	RegisterClientCommand = "RegisterClient"
	ListenTopicCommand    = "ListenTopic"
	SendMessageCommand    = "SendMessage"
)

type Message struct {
	Command string
	Data    interface{}
}

type RegisterClientMessage struct {
	ClientAddr string
}

type ListenTopicMessage struct {
	Topic      string
	ClientAddr string
}

type SendMessageMessage struct {
	Topic      string
	ClientAddr string
	Payload    []byte
}

func DecodeMessageFromConn(conn net.Conn) (*Message, error) {
	if err := conn.SetReadDeadline(time.Now().Add(5 * time.Second)); err != nil {
		return nil, fmt.Errorf("setting read deadline: %w", err)
	}

	totalLenBuf := make([]byte, 2)
	if _, err := io.ReadFull(conn, totalLenBuf); err != nil {
		return nil, fmt.Errorf("reading total length: %w", err)
	}
	totalLen := binary.BigEndian.Uint16(totalLenBuf)

	data := make([]byte, totalLen)
	if _, err := io.ReadFull(conn, data); err != nil {
		return nil, fmt.Errorf("reading message data: %w", err)
	}

	msg := &Message{}
	currentPos := 0

	// Read command
	if len(data) < 2 {
		return nil, fmt.Errorf("message too short for command length")
	}
	cmdLen := binary.BigEndian.Uint16([]byte(data[currentPos:]))
	currentPos += 2

	if len(data) < currentPos+int(cmdLen) {
		return nil, fmt.Errorf("message too short for command")
	}
	msg.Command = string(data[currentPos : currentPos+int(cmdLen)])
	currentPos += int(cmdLen)

	switch msg.Command {

	case RegisterClientCommand:
		data := &RegisterClientMessage{}

		// Read ClientAddr
		if len(data.ClientAddr) < currentPos+2 {
			return nil, fmt.Errorf("message too short for ClientAddr length")
		}
		ClientAddrLen := binary.BigEndian.Uint16([]byte(data.ClientAddr[currentPos:]))
		currentPos += 2

		if len(data.ClientAddr) < currentPos+int(ClientAddrLen) {
			return nil, fmt.Errorf("message too short for ClientAddr")
		}

		data.ClientAddr = string(data.ClientAddr[currentPos : currentPos+int(ClientAddrLen)])

		currentPos += int(ClientAddrLen)

		msg.Data = data

	case ListenTopicCommand:
		data := &ListenTopicMessage{}

		// Read Topic
		if len(data.Topic) < currentPos+2 {
			return nil, fmt.Errorf("message too short for Topic length")
		}
		TopicLen := binary.BigEndian.Uint16([]byte(data.Topic[currentPos:]))
		currentPos += 2

		if len(data.Topic) < currentPos+int(TopicLen) {
			return nil, fmt.Errorf("message too short for Topic")
		}

		data.Topic = string(data.Topic[currentPos : currentPos+int(TopicLen)])

		currentPos += int(TopicLen)

		// Read ClientAddr
		if len(data.ClientAddr) < currentPos+2 {
			return nil, fmt.Errorf("message too short for ClientAddr length")
		}
		ClientAddrLen := binary.BigEndian.Uint16([]byte(data.ClientAddr[currentPos:]))
		currentPos += 2

		if len(data.ClientAddr) < currentPos+int(ClientAddrLen) {
			return nil, fmt.Errorf("message too short for ClientAddr")
		}

		data.ClientAddr = string(data.ClientAddr[currentPos : currentPos+int(ClientAddrLen)])

		currentPos += int(ClientAddrLen)

		msg.Data = data

	case SendMessageCommand:
		data := &SendMessageMessage{}

		// Read Topic
		if len(data.Topic) < currentPos+2 {
			return nil, fmt.Errorf("message too short for Topic length")
		}
		TopicLen := binary.BigEndian.Uint16([]byte(data.Topic[currentPos:]))
		currentPos += 2

		if len(data.Topic) < currentPos+int(TopicLen) {
			return nil, fmt.Errorf("message too short for Topic")
		}

		data.Topic = string(data.Topic[currentPos : currentPos+int(TopicLen)])

		currentPos += int(TopicLen)

		// Read ClientAddr
		if len(data.ClientAddr) < currentPos+2 {
			return nil, fmt.Errorf("message too short for ClientAddr length")
		}
		ClientAddrLen := binary.BigEndian.Uint16([]byte(data.ClientAddr[currentPos:]))
		currentPos += 2

		if len(data.ClientAddr) < currentPos+int(ClientAddrLen) {
			return nil, fmt.Errorf("message too short for ClientAddr")
		}

		data.ClientAddr = string(data.ClientAddr[currentPos : currentPos+int(ClientAddrLen)])

		currentPos += int(ClientAddrLen)

		// Read Payload
		if len(data.Payload) < currentPos+2 {
			return nil, fmt.Errorf("message too short for Payload length")
		}
		PayloadLen := binary.BigEndian.Uint16([]byte(data.Payload[currentPos:]))
		currentPos += 2

		if len(data.Payload) < currentPos+int(PayloadLen) {
			return nil, fmt.Errorf("message too short for Payload")
		}

		data.Payload = data.Payload[currentPos : currentPos+int(PayloadLen)]

		currentPos += int(PayloadLen)

		msg.Data = data

	default:
		return nil, fmt.Errorf("unknown command: %s", msg.Command)
	}

	return msg, nil
}

func EncodeRegisterClientRequest(clientAddr string) ([]byte, error) {
	cmd := RegisterClientCommand
	totalLen := 2 + 2 + len(cmd) + 2 + len(clientAddr)

	buf := make([]byte, totalLen)
	currentPos := 0

	// Write total length
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(totalLen-2))
	currentPos += 2

	// Write command
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(len(cmd)))
	currentPos += 2
	copy(buf[currentPos:], cmd)
	currentPos += len(cmd)

	// Write ClientAddr
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(len(clientAddr)))
	currentPos += 2
	copy(buf[currentPos:], clientAddr)
	currentPos += len(clientAddr)

	return buf, nil
}

func EncodeListenTopicRequest(topic string, clientAddr string) ([]byte, error) {
	cmd := ListenTopicCommand
	totalLen := 2 + 2 + len(cmd) + 2 + len(topic) + 2 + len(clientAddr)

	buf := make([]byte, totalLen)
	currentPos := 0

	// Write total length
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(totalLen-2))
	currentPos += 2

	// Write command
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(len(cmd)))
	currentPos += 2
	copy(buf[currentPos:], cmd)
	currentPos += len(cmd)

	// Write Topic
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(len(topic)))
	currentPos += 2
	copy(buf[currentPos:], topic)
	currentPos += len(topic)

	// Write ClientAddr
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(len(clientAddr)))
	currentPos += 2
	copy(buf[currentPos:], clientAddr)
	currentPos += len(clientAddr)

	return buf, nil
}

func EncodeSendMessageRequest(topic string, clientAddr string, payload []byte) ([]byte, error) {
	cmd := SendMessageCommand
	totalLen := 2 + 2 + len(cmd) + 2 + len(topic) + 2 + len(clientAddr) + 2 + len(payload)

	buf := make([]byte, totalLen)
	currentPos := 0

	// Write total length
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(totalLen-2))
	currentPos += 2

	// Write command
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(len(cmd)))
	currentPos += 2
	copy(buf[currentPos:], cmd)
	currentPos += len(cmd)

	// Write Topic
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(len(topic)))
	currentPos += 2
	copy(buf[currentPos:], topic)
	currentPos += len(topic)

	// Write ClientAddr
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(len(clientAddr)))
	currentPos += 2
	copy(buf[currentPos:], clientAddr)
	currentPos += len(clientAddr)

	// Write Payload
	binary.BigEndian.PutUint16(buf[currentPos:], uint16(len(payload)))
	currentPos += 2
	copy(buf[currentPos:], payload)
	currentPos += len(payload)

	return buf, nil
}
