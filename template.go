package ptlbuilder

const protocolTemplate = `
// Code generated by ptlbuilder;
package {{.Package}}

import (
    "encoding/binary"
    "fmt"
    "io"
    "net"
    "time"
)

const (
    {{range .Commands}}
    {{.Name}}Command = "{{.Name}}"
    {{- end}}
)

type Message struct {
    Command string
    Data    interface{}
}

{{range .Commands}}
type {{.Name}}Message struct {
    {{range .Fields}}
    {{.Name}} {{.Type}}
    {{- end}}
}
{{end}}

func DecodeMessageFromConn(conn net.Conn) (*Message, error) {
    if err := conn.SetReadDeadline(time.Now().Add(time.Duration({{.Timeout}}) * time.Second)); err != nil {
        return nil, fmt.Errorf("setting read deadline: %w", err)
    }

    // read total length of the message first
    totalLenBuf := make([]byte, 2)
    if _, err := io.ReadFull(conn, totalLenBuf); err != nil {
        return nil, fmt.Errorf("reading total length: %w", err)
    }
    totalLen := binary.BigEndian.Uint16(totalLenBuf)

    // make the buffer for storing the whole message
    data := make([]byte, totalLen)
    if _, err := io.ReadFull(conn, data); err != nil {
        return nil, fmt.Errorf("reading message data: %w", err)
    }

    msg := &Message{}
    currentPos := 0

    // Read command
    if len(data) < 2 {
        return nil, fmt.Errorf("message too short for command length")
    }
    cmdLen := binary.BigEndian.Uint16([]byte(data[currentPos:]))
    currentPos += 2

    if len(data) < currentPos+int(cmdLen) {
        return nil, fmt.Errorf("message too short for command")
    }
    msg.Command = string(data[currentPos : currentPos+int(cmdLen)])
    currentPos += int(cmdLen)

    switch msg.Command {
    {{range .Commands}}
    case {{.Name}}Command:
        msgData := &{{.Name}}Message{}
        {{range .Fields}}
        // Read {{.Name}}
        if len(data) < currentPos+2 {
            return nil, fmt.Errorf("message too short for {{.Name}} length")
        }
        {{.Name}}Len := binary.BigEndian.Uint16(data[currentPos:])
        currentPos += 2

        if len(data) < currentPos+int({{.Name}}Len) {
            return nil, fmt.Errorf("message too short for {{.Name}}")
        }
        {{if eq .Type "[]byte"}}
        msgData.{{.Name}} = data[currentPos : currentPos+int({{.Name}}Len)]
        {{else}}
        msgData.{{.Name}} = string(data[currentPos : currentPos+int({{.Name}}Len)])
        {{end}}
        currentPos += int({{.Name}}Len)
        {{end}}
        msg.Data = msgData
    {{end}}
    default:
        return nil, fmt.Errorf("unknown command: %s", msg.Command)
    }

    return msg, nil
}

{{range .Commands}}
func Encode{{.Name}}Request({{range $i, $f := .Fields}}{{if $i}}, {{end}}{{lower $f.Name}} {{$f.Type}}{{end}}) ([]byte, error) {
    cmd := {{.Name}}Command
    totalLen := 2 + 2 + len(cmd){{range .Fields}} + 2 + len({{lower .Name}}){{end}}

    buf := make([]byte, totalLen)
    currentPos := 0

    // Write total length
    binary.BigEndian.PutUint16(buf[currentPos:], uint16(totalLen-2))
    currentPos += 2

    // Write command
    binary.BigEndian.PutUint16(buf[currentPos:], uint16(len(cmd)))
    currentPos += 2
    copy(buf[currentPos:], cmd)
    currentPos += len(cmd)

    {{range .Fields}}
    // Write {{.Name}}
    binary.BigEndian.PutUint16(buf[currentPos:], uint16(len({{lower .Name}})))
    currentPos += 2
    copy(buf[currentPos:], {{lower .Name}})
    currentPos += len({{lower .Name}})
    {{end}}

    return buf, nil
}
{{end}}

{{range .Commands}}
func (m *Message) As{{.Name}}() (*{{.Name}}Message, error) {
    if m.Command != {{.Name}}Command {
        return nil, fmt.Errorf("invalid command type: expected %s, got %s", {{.Name}}Command, m.Command)
    }

    data, ok := m.Data.(*{{.Name}}Message)
    if !ok {
        return nil, fmt.Errorf("invalid data type for {{.Name}}Message")
    }

    return data, nil
}
{{end}}
`

const documentTemplate = `# Protocol Documentation

## Message Format
Each message follows this general structure:
* Total packet length (4 bytes)
* Command name length (2 bytes)
* Command name string
* Sequence of fields, each containing:
  * Field length (4 bytes)
  * Field data

## Commands

{{range $command := .Commands}}
### {{$command.Name}}

**Command Structure:**
{{char}}
[Total Length: 4 bytes]
[Command Length: 2 bytes]["{{$command.Name}}"]
{{- range $index, $field := $command.Fields}}
[Field {{inc $index}} Length: 4 bytes][{{$field.Name}} ({{$field.Type}})]
{{- end}}
{{char}}

**Fields:**
{{- range $index, $field := $command.Fields}}
{{inc $index}}. **{{$field.Name}}**
   * Type: {{$field.Type}}
{{- end}}

{{end}}

## Notes
* All integer values are in network byte order (big-endian)
* String fields are UTF-8 encoded
* Timeout for message decoding: {{.Timeout}} seconds
`
