package ptlbuilder

const protocolTemplate = `
// Code generated by ptlbuilder;
package {{.Package}}

import (
    "encoding/binary"
    "fmt"
    "io"
    "net"
    "time"
)

const (
    {{range .Commands}}
    {{.Name}}Command = "{{.Name}}"
    {{- end}}
)

type Message struct {
    Command string
    Data    interface{}
}

{{range .Commands}}
type {{.Name}}Message struct {
    {{range .Fields}}
    {{.Name}} {{.Type}}
    {{- end}}
}
{{end}}

func DecodeMessageFromConn(conn net.Conn) (*Message, error) {
    if err := conn.SetReadDeadline(time.Now().Add(5 * time.Second)); err != nil {
        return nil, fmt.Errorf("setting read deadline: %w", err)
    }

    totalLenBuf := make([]byte, 2)
    if _, err := io.ReadFull(conn, totalLenBuf); err != nil {
        return nil, fmt.Errorf("reading total length: %w", err)
    }
    totalLen := binary.BigEndian.Uint16(totalLenBuf)

    data := make([]byte, totalLen)
    if _, err := io.ReadFull(conn, data); err != nil {
        return nil, fmt.Errorf("reading message data: %w", err)
    }

    msg := &Message{}
    currentPos := 0

    // Read command
    if len(data) < 2 {
        return nil, fmt.Errorf("message too short for command length")
    }
    cmdLen := binary.BigEndian.Uint16([]byte(data[currentPos:]))
    currentPos += 2

    if len(data) < currentPos+int(cmdLen) {
        return nil, fmt.Errorf("message too short for command")
    }
    msg.Command = string(data[currentPos : currentPos+int(cmdLen)])
    currentPos += int(cmdLen)

        switch msg.Command {
    {{range .Commands}}
    case {{.Name}}Command:
        data := &{{.Name}}Message{}
        {{range .Fields}}
        // Read {{.Name}}
        if len(data.{{.Name}}) < currentPos+2 {
            return nil, fmt.Errorf("message too short for {{.Name}} length")
        }
        {{.Name}}Len := binary.BigEndian.Uint16([]byte(data.{{.Name}}[currentPos:]))
        currentPos += 2

        if len(data.{{.Name}}) < currentPos+int({{.Name}}Len) {
            return nil, fmt.Errorf("message too short for {{.Name}}")
        }
        {{if eq .Type "[]byte"}}
        data.{{.Name}} = data.{{.Name}}[currentPos : currentPos+int({{.Name}}Len)]
        {{else}}
        data.{{.Name}} = string(data.{{.Name}}[currentPos : currentPos+int({{.Name}}Len)])
        {{end}}
        currentPos += int({{.Name}}Len)
        {{end}}
        msg.Data = data
    {{end}}
    default:
        return nil, fmt.Errorf("unknown command: %s", msg.Command)
    }

    return msg, nil
}

{{range .Commands}}
func Encode{{.Name}}Request({{range $i, $f := .Fields}}{{if $i}}, {{end}}{{lower $f.Name}} {{$f.Type}}{{end}}) ([]byte, error) {
    cmd := {{.Name}}Command
    totalLen := 2 + 2 + len(cmd){{range .Fields}} + 2 + len({{lower .Name}}){{end}}

    buf := make([]byte, totalLen)
    currentPos := 0

    // Write total length
    binary.BigEndian.PutUint16(buf[currentPos:], uint16(totalLen-2))
    currentPos += 2

    // Write command
    binary.BigEndian.PutUint16(buf[currentPos:], uint16(len(cmd)))
    currentPos += 2
    copy(buf[currentPos:], cmd)
    currentPos += len(cmd)

    {{range .Fields}}
    // Write {{.Name}}
    binary.BigEndian.PutUint16(buf[currentPos:], uint16(len({{lower .Name}})))
    currentPos += 2
    copy(buf[currentPos:], {{lower .Name}})
    currentPos += len({{lower .Name}})
    {{end}}

    return buf, nil
}
{{end}}
`
